import os
import shutil
import tempfile
import zipfile
import logging
import asyncio
from typing import Tuple, Set

from .decompiler import decompile_class_files
from .java_cleaner import clean_java_file, analyze_java_file
from .directory_utils import normalize_directory_structure

logger = logging.getLogger(__name__)


def has_javassist_folder(jar_path: str) -> bool:
    """Check if JAR contains javassist folder at root level."""
    with zipfile.ZipFile(jar_path, 'r') as jar:
        file_list = jar.namelist()
        return any(name.startswith('javassist/') or name == 'javassist' for name in file_list)


def process_directories(temp_dir: str, class_name: str) -> Tuple[Set[str], Set[str]]:
    """Process directories to remove malicious components and clean Java files."""
    removed_paths = set()
    removed_dirs = set()

    # Remove javassist folder
    javassist_path = os.path.join(temp_dir, 'javassist')
    if os.path.exists(javassist_path):
        shutil.rmtree(javassist_path)
        removed_paths.add(javassist_path)
        logger.info("Removed javassist folder")

    # Remove single-character directories
    for root, dirs, _ in os.walk(temp_dir):
        for dir_name in dirs[:]:
            if len(dir_name) == 1:
                dir_path = os.path.join(root, dir_name)
                shutil.rmtree(dir_path)
                removed_paths.add(dir_path)
                removed_dirs.add(dir_name)
                logger.info(f"Removed directory: {dir_name}")
                dirs.remove(dir_name)

    # Clean Java files and remove suspicious class files
    for root, _, files in os.walk(temp_dir):
        for file in files:
            file_path = os.path.join(root, file)
            if file.endswith('.java'):
                try:
                    clean_java_file(file_path, class_name, removed_dirs)
                except Exception as e:
                    logger.error(f"Failed to clean {file_path}: {e}")
            elif file.endswith('.class'):
                base_name = file[:-6]
                if (base_name.startswith(class_name) and
                        base_name != class_name and
                        len(base_name) == len(class_name) + 3):
                    try:
                        os.remove(file_path)
                        removed_paths.add(file_path)
                        logger.info(f"Removed suspicious class file: {file}")
                    except Exception as e:
                        logger.error(f"Failed to remove class file {file}: {e}")

    return removed_paths, removed_dirs


def process_jar_file(jar_path: str) -> None:
    """Process a single JAR file to remove malware components."""
    logger.info(f"Processing JAR file: {jar_path}")

    if not has_javassist_folder(jar_path):
        logger.info(f"Skipping {jar_path} - no javassist folder found")
        return

    temp_dir = tempfile.mkdtemp()
    try:
        # Extract JAR contents
        with zipfile.ZipFile(jar_path, 'r') as jar:
            jar.extractall(temp_dir)

        # Decompile class files
        success, failed_files = asyncio.run(decompile_class_files(temp_dir))
        if not success:
            logger.error("Decompilation failed")
            return

        # Find plugin class
        java_files = [os.path.join(root, f)
                      for root, _, files in os.walk(temp_dir)
                      for f in files if f.endswith('.java')]

        plugin_class_info = None
        for java_file in java_files:
            if result := analyze_java_file(java_file):
                plugin_class_info = result
                break

        if not plugin_class_info:
            logger.warning("No JavaPlugin class found")
            return

        class_path, class_name = plugin_class_info
        removed_paths, removed_dirs = process_directories(temp_dir, class_name)
        normalize_directory_structure(temp_dir)

        # Create cleaned JAR
        output_jar = jar_path[:-4] + "_cleaned.jar"
        with zipfile.ZipFile(output_jar, 'w', zipfile.ZIP_DEFLATED) as jar:
            for root, _, files in os.walk(temp_dir):
                for file in files:
                    abs_path = os.path.join(root, file)
                    rel_path = os.path.relpath(abs_path, temp_dir)

                    if any(os.path.normpath(abs_path).startswith(os.path.normpath(p))
                           for p in removed_paths):
                        continue

                    jar_path = rel_path.replace(os.sep, '/')
                    jar.write(abs_path, jar_path)

        logger.info(f"Created cleaned JAR: {output_jar}")

    except Exception as e:
        logger.error(f"Error processing {jar_path}: {e}")
    finally:
        shutil.rmtree(temp_dir)